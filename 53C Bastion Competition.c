#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    autoPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl3,  sensor_Lift,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightFront,     sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  leftFront,      sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  leftBack,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightBack,      sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           clawRight,     tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftDT,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightDT,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           topRight,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port5,           midRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           botRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           botLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           midLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           topLeft,       tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          clawLeft,      tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define e 2.718281828

//Y DRIVETRAIN PROGRAM

//---Motor Connections---//
// Drivetrain -- 2,3,4,5
// Lift -- 7,7,8,9

//-------------Initialize Variables-------------//


// Autonomous Mode Variables
int autoMode = 1;
int driveForward = 1;
int driveBack = -1;
int left = 1;
int right = 2;
int forwards = 1;
int backwards = -1;
float wheelBase = 11.0; // Given in inches
float fullTurnCircumference = PI * wheelBase;
float wheelRotationDistance = 4.0 * PI;

//---Variables for User Control---//
bool reverser = false;
bool b7DOld = false;
bool sound = false;
bool b8DOld = false;
bool hold = false;
int driverControlModeCount = 1;

//---Joystick Variables & Deadzone--//
int Y2 = 0, Y1 = 0, threshold = 15;

//---Constant lift parameters---//
int liftEncoderMaxValue = 127;
int liftEncoderMinValue = 0;
int liftMaxSpeed = 120;
int up = 1;
int down = -1;

//---Used as to control automatic lift---//
bool autoRaiseLift = false;
bool autoLowerLift = false;
bool liftAutoMode = false;
bool autoMiddleLift = false;
int lift;

//-------------PID LOOPS--------------//
#pragma DebuggerWindows("Globals")
#pragma DebuggerWindows("Motors")

//---User Functions---//
void moveBase(int speed)
{
	motor[leftDT] = speed;
	motor[rightDT] = speed;
}

void moveRightBase (int speed)
{
	motor[rightDT] = speed;
}

void moveLeftBase (int speed)
{
	motor[leftDT] = speed;
}

void turnBase(int speed) //positive is clockwise
{
	motor[leftDT] = speed;
	motor[rightDT] = -speed;
}

//reading: ticks -- 627.2 ticks/revolution for a torque motor
//reading: ticks -- 392 ticks/revolution for a high speed motor
//reading: ticks -- 261.333 ticks/revolution for a turbo speed motor
//for every 1 turn of the wheels -- 4 inch wheels = 627.2 ticks
//for every 1 turn of each wheel 4*pi inches
//for every 4*pi inches = 627.2*2 ticks
//ticks/inch = 627.2*2/(4*pi) = 99.82198 for torque motor
//ticks/inch = 392*2/(4*pi) = 32.38874 for high speed motor
//ticks/inch = 261.333*2/(4*pi) = 41.59244 for turbo speed motor

//when my error is 30, the actual error in inches = .3


//------User Conversions-------//
int inchtoTicks (float inch) //torque motor
{
	int ticks;
	ticks = inch*(627.2 *2 /( 4*PI));
	return ticks;
}

int degreesToTicks (float degree) //method is more accurate
{
	int ticksPerTurn = 3000; //this value is just a placeholder, not sure how many ticks per turn, depends on robot, we will have to calculate this
	int ticks = degree * ticksPerTurn / 360;
	return ticks;
}

int timerValue (float seconds)
{
	int miliseconds;
	miliseconds = seconds * 1000;
	if (miliseconds > 250)
	{
		miliseconds = 250;
	}
	return miliseconds;
}

//-------------MAIN PID CONTROLLER-------------//
void PIDBaseControl (float distance, float waitTime, float maxPower = 1)
{
	float Kp = .2; //constant
	float Ki = 0.05; //constant...might want to be even closer to 0.0
	float Kd = 0.5; //might have to change this
	int error;
	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;
	float integralActiveZone = inchtoTicks(1.5); //value will probably have to get changed, smaller or larger
	float integralPowerLimit = 50/Ki;
	int finalPower;
	float Kp_C = 0.01; //if you dont want drift error set this value to 0
	int error_drift;
	float proportion_drift;
	bool timerBool = true;
	nMotorEncoder[rightFront] = 0;
	nMotorEncoder[rightBack] = 0;
	nMotorEncoder[leftFront] = 0;
	nMotorEncoder[leftBack] = 0;
	clearTimer(T1);


	while (time1[T1] < timerValue(waitTime))
	{
		error = inchtoTicks(distance) - (nMotorEncoder[rightFront] + nMotorEncoder[rightBack] + nMotorEncoder[leftFront] + nMotorEncoder[leftBack]);
		proportion = Kp * error;
		if (abs(error) < integralActiveZone && error != 0)
		{
			integralRaw = integralRaw + error;
		}
		else
		{
			integralRaw = 0;
		}
		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		if (integralRaw < -integralPowerLimit)
		{
			integralRaw = - integralPowerLimit;
		}
		integral = Ki * integralRaw;
		derivative = Kd*(error - lastError);
		lastError = error;
		if (error == 0)
		{
			derivative = 0;
		}
		finalPower = proportion + integral + derivative; //proportion + derivative + integral
		if (finalPower > maxPower * 127)
		{
			finalPower = maxPower * 127;
		}
		else if (finalPower < -maxPower * 127)
		{
			finalPower = -maxPower * 127;
		}
		error_drift = (nMotorEncoder[rightFront] + nMotorEncoder[rightBack]) - (nMotorEncoder[leftFront] + nMotorEncoder[leftBack]);
		proportion_drift = Kp_C * error_drift;
		moveLeftBase (finalPower + proportion_drift);
		moveRightBase(finalPower - proportion_drift);
		wait1Msec(40);
		if (error < 30)
		{
			timerBool = false;
		}
		if (timerBool)
		{
			clearTimer(T1);
		}
	}
	moveBase(0);
}

//PID control for 0degree turning
void PIDBaseTurn (float distance, float waitTime, float maxPower = 1)
{
	//constants might want to be a little bigger, play around with them
	float Kp = .2; //constant
	float Ki = 0.05; //constant...might want to be even closer to 0.0
	float Kd = 0.5; //might have to change this
	int error;
	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;
	float integralActiveZone = inchtoTicks(1.5); //value will probably have to get changed, smaller or larger
	float integralPowerLimit = 50/Ki;
	int finalPower;
	bool timerBool = true;
	nMotorEncoder[rightFront] = 0;
	nMotorEncoder[rightBack] = 0;
	nMotorEncoder[leftFront] = 0;
	nMotorEncoder[leftBack] = 0;
	clearTimer(T1);


	while (time1[T1] < timerValue(waitTime))
	{
		error = degreesToTicks(distance) - ((nMotorEncoder[leftFront] + nMotorEncoder[leftBack]) - (nMotorEncoder[rightFront] + nMotorEncoder[rightBack]));
		proportion = Kp * error;
		if (abs(error) < integralActiveZone && error != 0)
		{
			integralRaw = integralRaw + error;
		}
		else
		{
			integralRaw = 0;
		}
		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		if (integralRaw < -integralPowerLimit)
		{
			integralRaw = - integralPowerLimit;
		}
		integral = Ki * integralRaw;
		derivative = Kd*(error - lastError);
		lastError = error;
		if (error == 0)
		{
			derivative = 0;
		}
		finalPower = proportion + integral + derivative; //proportion + derivative + integral
		if (finalPower > maxPower * 127)
		{
			finalPower = maxPower * 127;
		}
		else if (finalPower < -maxPower * 127)
		{
			finalPower = -maxPower * 127;
		}
		turnBase(finalPower);
		wait1Msec(40);
		if (error < 30)
		{
			timerBool = false;
		}
		if (timerBool)
		{
			clearTimer(T1);
		}
	}
	turnBase(0);
}

//-------------Robot Functions-------------//


void moveBase(float distance, int speed)
{
	SensorValue[rightFront] = 0;
	while (inchtoTicks(SensorValue[rightFront]) < distance) {
		motor[leftDT] = speed;
		motor[rightDT] = speed;
	}
}

// Stops the drivetrain movement
void stopMovement(){
	motor[leftDT] = 0;
	motor[rightDT] = 0;
}


// Moves the lift. Takes two parameters: direction and speed.
void moveLift(int direction, int liftSpeed){
	lift = direction * liftSpeed;
	motor[topLeft] = lift;
	motor[midLeft] = lift;
	motor[botLeft] = lift;
	motor[topRight] = lift;
	motor[midRight] = lift;
	motor[botRight] = lift;
}

// Backspins the lift motors to keep it from falling
void holdLift() {
	moveLift(up, 10);
}

// Calls the holdLift() function to lock the lift
void stopLift(){
	moveLift(up, 0);
	autoLowerLift = false;
	autoRaiseLift = false;
}

// Raises the lift
void raiseLift() {
	moveLift(up, liftMaxSpeed);
}

// Lower the lift
void lowerLift(){
	moveLift(down, liftMaxSpeed);
}

// Controls for the claw
void openClaw(){
	motor[clawRight] = 127;
	motor[clawLeft] = 127;
}

void closeClaw(){
	motor[clawRight] = -127;
	motor[clawLeft] = -127;
}

void stopClaw(){
	motor[clawRight] = 0;
	motor[clawLeft] = 0;
}

// Automatic lift function: takes three parameters, telling it what mode to enter.
void automaticLift(bool autoRaiseLift, bool autoLowerLift, bool autoMiddleLift) {
	// These statements stop the lift once it has reached its desired height
	if (autoRaiseLift || autoLowerLift || autoMiddleLift){
		if (SensorValue[sensor_Lift] > liftEncoderMaxValue){
			autoRaiseLift = false;
		}
		if (SensorValue[sensor_Lift] < liftEncoderMinValue){
			autoLowerLift = false;
		}
		if (autoMiddleLift && (SensorValue[sensor_Lift] <= 55) && (SensorValue[sensor_Lift] >= 50)){
			autoMiddleLift = false;
		}
		if (autoRaiseLift == false && autoLowerLift == false && autoMiddleLift == false){
			stopLift();
			liftAutoMode = false;
		}
	}

	// Moves the lift
	if (autoRaiseLift) {
		raiseLift();
	}
	if (autoLowerLift) {
		lowerLift();
	}
	// For positioning the lift in the center, determines whether it needs to go up or down
	if (autoMiddleLift){
		if (SensorValue[sensor_Lift] > 55){
			lowerLift();
		}
		if (SensorValue[sensor_Lift] < 50) {
			raiseLift();
		}
	}
}

//----LCD Functions----//
void clearLCD()
{
	clearLCDLine(0);
	clearLCDLine(1);
}

void displayBatteryVoltage()
{
	string mainBatteryVoltage;
	string secondaryBatteryVoltage;//secondary battery
	displayLCDString(0, 0, "Main:");
	displayLCDString(1, 0, "Second:");
	sprintf(mainBatteryVoltage, "%1.2f%c", nImmediateBatteryLevel/1000.0, 'V');
	sprintf(secondaryBatteryVoltage, "%1.3c%", BackupBatteryLevel/1000.0, 'V');
	displayLCDString(0, 8, mainBatteryVoltage);
	displayLCDString(1, 8, secondaryBatteryVoltage);

}

task driverControlViewValues()
{
	clearLCD();
	while (true)
	{
		if (nLCDButtons == 1)
		{
			driverControlModeCount--;
			clearLCD();
			while(nLCDButtons == 1)
			{
				wait1Msec(10);
			}
		}
		if (nLCDButtons == 4)
		{
			driverControlModeCount++;
			clearLCD();
			while(nLCDButtons == 4)
			{
				wait1Msec(10);
			}
		}
		if (driverControlModeCount < 1)
		{
			driverControlModeCount = 12;
		}
		else if (driverControlModeCount > 12)
		{
			driverControlModeCount = 1;
		}
		if (driverControlModeCount == 1)
		{
			displayBatteryVoltage();
		}
		else if (driverControlModeCount == 2)
		{
			displayLCDCenteredString(0, "Currently");
			displayLCDCenteredString(1, "Empty");
		}
		else if (driverControlModeCount == 3)
		{
			displayLCDCenteredString(0, "Currently");
			displayLCDCenteredString(1, "Empty");
		}
		else if (driverControlModeCount == 4)
		{
			displayLCDCenteredString(0, "Currently");
			displayLCDCenteredString(1, "Empty");
		}
		else if (driverControlModeCount == 5)
		{
			displayLCDCenteredString(0, "Currently");
			displayLCDCenteredString(1, "Empty");
		}
		else if (driverControlModeCount == 6)
		{
			displayLCDCenteredString(0, "Currently");
			displayLCDCenteredString(1, "Empty");
		}
		else if (driverControlModeCount == 7)
		{
			displayLCDCenteredString(0, "Currently");
			displayLCDCenteredString(1, "Empty");
		}
		else if (driverControlModeCount == 8)
		{
			displayLCDCenteredString(0, "Currently");
			displayLCDCenteredString(1, "Empty");
		}
		wait1Msec(10);
	}
}

void autoSelection()
{
	clearLCD();
	while (nLCDButtons != 2)
	{
		displayLCDCenteredString(0, "Autonomous");
		displayLCDNumber(0, 14, autoMode, 2);
		displayLCDCenteredString(1, "<< Selection >>");
		if (nLCDButtons == 1)
		{
			autoMode--;
			while(nLCDButtons == 1)
			{
				wait1Msec(10);
			}
		}
		if (nLCDButtons == 4)
		{
			autoMode++;
			while (nLCDButtons == 4)
			{
				wait1Msec(10);
			}
		}
		if (autoMode < 1)
		{
			autoMode = 12;
		}
		else if (autoMode > 12)
		{
			autoMode = 1;
		}
		wait1Msec(10);
	}
	clearLCD();
}

//right side cube auto
void auto1()
{
	openClaw();
	wait1Msec(250);
	stopClaw();
	wait1Msec(250);
	lowerLift();
	wait1Msec(500);
	moveBase(sqrt(4)*12, -100);
	stopMovement();
	wait1Msec(500);
	closeClaw();
	raiseLift();
	wait1Msec(250);
	stopLift();
	holdLift();
	wait1Msec(250);
	SensorValue[rightFront] = 0;
	SensorValue[leftFront] = 0;
	SensorValue[rightBack] = 0;
	SensorValue[leftBack] = 0;
	wait1Msec(500);
	wait1Msec(500);
	while(SensorValue[rightFront] - SensorValue[leftFront] < 400) {
		motor[leftDT] = 80;
		motor[rightDT] = -80;
	}
	motor[leftDT] = 80;
	motor[rightDT] = 80;
	wait1Msec(800);
	stopMovement();
	wait1Msec(200);
	raiseLift();
	wait1Msec(850);
	openClaw();
	wait1Msec(400);
	stopLift();
	wait1Msec(100);
	stopClaw();
}

//right side star auto
void auto2()
{
	openClaw();
	wait1Msec(500);
	stopClaw();
	wait1Msec(3000);
	lowerLift();
	wait1Msec(500);
	closeClaw();
	wait1Msec(200);
	stopClaw();
	wait1Msec(500);
	motor[leftDT] = -100;
	motor[rightDT] = -100;
	wait1Msec(2500);
	stopMovement();
	wait1Msec(100);
	closeClaw();
	raiseLift();
	wait1Msec(800);
	holdLift();
	wait1Msec(500);
	motor[leftDT] = 100;
	motor[rightDT] = 100;
	wait1Msec(1200);
	stopMovement();
	wait1Msec(100);
	motor[leftDT] = -50;
	motor[leftDT] = 50;
	wait1Msec(1550);
	motor[leftDT] = 100;
	motor[rightDT] = 100;
	wait1Msec(1000);
	raiseLift();
	wait1Msec(300);
	openClaw();
	wait1Msec(1000);
	stopClaw();
	wait1Msec(3000);
	stopLift();
}

//right side cube and star auto
void auto3()
{
	PIDBaseControl(12, 1, 50);
	wait1Msec(1000);
	PIDBaseTurn(45, 1, 30);
}

//left side cube auto
void auto4()
{
}

//left side star auto
void auto5()
{
}

//left side cube and star auto
void auto6()
{
}

//PID cube right auto
void auto7()
{
}

//PID star right auto
void auto8()
{
}

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	autoSelection();
}


//-------------Autonomous Code-------------//


task autonomous()
{
	if (autoMode == 1)
	{
		auto1();
	}
	else if (autoMode == 2)
	{
		auto2();
	}
	else if (autoMode == 3)
	{
		auto3();
	}
	else if (autoMode == 4)
	{
		auto4();
	}
	else if (autoMode == 5)
	{
		auto5();
	}
	else if (autoMode == 6)
	{
		auto6();
	}
	else if (autoMode == 7)
	{
		auto7();
	}
	else if (autoMode == 8)
	{
		auto8();
	}
}


//-------------User Control Code-------------//

task usercontrol()
{
	while (true)
	{
		// Strike fear into the hearts of our opponents
		if (!sound && vexRT[Btn8U]==1){
			playSoundFile("sound.wav");
			sound = true;
		}
		if (sound && vexRT[Btn8D]==0){
			sound = false;
		}

		// Enables reverse mode
		if (vexRT[Btn7D] == 1 && !b8DOld) {
			if (reverser == false){
				reverser = true;
			}
			else if (reverser){
				reverser = false;
			}
			b7DOld = true;
		}

		if (vexRT[Btn7D] == 0 && b7DOld){
			b7DOld = false;
		}

		//Create "deadzone" for Y1/Ch2
		if(abs(vexRT[Ch2]) > threshold)
			Y1 = -vexRT[Ch2];
		else
			Y1 = 0;
		//Create "deadzone" for Y2/Ch3
		if(abs(vexRT[Ch3]) > threshold)
			Y2 = vexRT[Ch3];
		else
			Y2 = 0;

		//Remote Control Commands

		if (reverser){ // Reverses the controls
			motor[rightDT] = Y2;
			motor[leftDT] = -Y1;
		}
		if (!reverser){
			motor[rightDT] = Y1;
			motor[leftDT] = -Y2;
		}


		//Remote Control Commands

		if (reverser){ // Reverses the controls
			motor[rightDT] = Y2;
			motor[leftDT] = -Y1;
		}
		if (!reverser){
			motor[rightDT] = Y1;
			motor[leftDT] = -Y2;
		}

		//---Manual Lift Control--//

		// Disable the automatic lift if any manual lift input detected
		if (vexRT[Btn6D] == 1 || vexRT[Btn6U] == 1 || vexRT[Btn8D] == 1){
			liftAutoMode = false;
		}

		// Raise lift
		if (vexRT[Btn6U] == 1 && !hold) {
			raiseLift();
		}

		// Lower lift
		if (vexRT[Btn6D] == 1 && !hold) {
			lowerLift();
		}

		// Enable or disable hold mode
		if (vexRT[Btn8D] == 1 && !b8DOld){
			if (hold == false){
				hold = true;
			}
			else{
				hold = false;
			}
			b8DOld = true;
		}
		if (vexRT[Btn8D] == 0 && b8DOld){
			b8DOld = false;
		}

		// Locks the lift in place
		if (hold){
			holdLift();
		}

		// Manually disable the lift
		if (vexRT[Btn6U] == 0 && !hold && vexRT[Btn6D] == 0 && !liftAutoMode) {
			stopLift();
		}

		// Claw
		if (vexRT[Btn5U] == 1){
			openClaw();
		}
		if (vexRT[Btn5D] == 1){
			closeClaw();
		}
		if (vexRT[Btn5D] == 0 && vexRT[Btn5U] == 0){
			stopClaw();
		}

		//--- Automatic Lift Control---//

		// Enables automatic raise to top
		if (vexRT[Btn7R] == 1 && !autoRaiseLift){
			autoLowerLift = false;
			autoRaiseLift = true;
			autoMiddleLift = false;
			liftAutoMode = true;
		}

		// Enables automatic lower to bottom
		if (vexRT[Btn7L] == true && !autoLowerLift) {
			autoRaiseLift = false;
			autoLowerLift = true;
			autoMiddleLift = false;
			liftAutoMode = true;
		}

		// Enables raise or lower to midpoint
		if (vexRT[Btn7U] == true && !autoLowerLift) {
			autoRaiseLift = false;
			autoLowerLift = false;
			autoMiddleLift = true;
			liftAutoMode = true;
		}

		// Execute the automatic raise
		if (liftAutoMode){
			automaticLift(autoRaiseLift, autoLowerLift, autoMiddleLift);
		}
		// Turns off the automatic lift
		if ((autoLowerLift || autoRaiseLift || autoMiddleLift) && !liftAutoMode){
			stopLift();
		}
	}
}
