#pragma config(Sensor, in1,    leftClawPot,    sensorPotentiometer)
#pragma config(Sensor, in2,    rightClawPot,   sensorPotentiometer)
#pragma config(Sensor, dgtl1,  sensorLift,     sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightFront,     sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  leftFront,      sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  leftBack,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightBack,      sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  rightIME,       sensorNone)
#pragma config(Sensor, I2C_2,  leftIME,        sensorNone)
#pragma config(Motor,  port1,           clawRight,     tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftDT,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightDT,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           topRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           midRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           botRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           botLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           midLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           topLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          clawLeft,      tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#define e 2.718281828

//Y DRIVETRAIN PROGRAM

//---Motor Connections---//
// Drivetrain -- 2,3 -- DT y'd off
// Lift -- 4,5,6,7,8,9
//Claw -- 1,2

//-------------Initialize Variables-------------//


// Autonomous Mode Variables
int auton = 0;
int left = 1;
int right = 2;

//---Variables for User Control---//
bool reverser = false;
int driverControlModeCount = 1;
bool autoClaw = false;

//---Joystick Variables & Deadzone--//
int Y2 = 0, Y1 = 0, threshold = 15;

//---Constant lift parameters---//
int liftEncoderMaxValue = 40;
int liftEncoderMinValue = 0;
int liftMaxSpeed = 127;
int up = 1;
int down = -1;

//---Used as to control automatic lift---//
bool autoRaiseLift = false;
bool autoLowerLift = false;
bool liftAutoMode = false;
int lift;

#pragma DebuggerWindows("Globals")
#pragma DebuggerWindows("Motors")


void clearEncoders(){
	SensorValue[leftBack] = 0;
	SensorValue[leftFront] = 0;
	SensorValue[rightBack] = 0;
	SensorValue[rightFront] = 0;
}

//------User Conversions-------//
int inchToTicks (float inch) //torque motor
{
	int ticks;
	ticks = inch*(90/( 4*PI));
	return ticks;
}

int degreesToTicks (float degree) //method is more accurate
{
	int ticksPerTurn = inchToTicks((11*PI)); //this value is just a placeholder, not sure how many ticks per turn, depends on robot, we will have to calculate this
	int ticks = degree * ticksPerTurn / 360;
	return ticks;
}

void driveForwardInches(float inch){
	int distance = inchToTicks(inch) * 12.4;
	clearEncoders();
	motor[leftDT] = 50;
	motor[rightDT] = 50;
	while ((SensorValue[leftBack] + SensorValue[leftFront] + SensorValue[rightFront] + SensorValue[rightBack]) < distance){}
	motor[leftDT] = 0;
	motor[rightDT] = 0;
}

void driveBackwardInches(float inch){
	int distance = inchToTicks(inch) * -12.4;
	clearEncoders();
	motor[leftDT] = -50;
	motor[rightDT] = -50;
	while ((SensorValue[leftBack] + SensorValue[leftFront] + SensorValue[rightFront] + SensorValue[rightBack]) > distance){}
	motor[leftDT] = 0;
	motor[rightDT] = 0;
}

void degreeTurn(float degree, int direction){
	int turnTicks = 6.9 * degreesToTicks(degree);
	clearEncoders();
	if (direction == left){
		motor[leftDT] = -50;
		motor[rightDT] = 50;
		while (((SensorValue[leftBack] + SensorValue[leftFront]) >= -turnTicks) && ((SensorValue[rightBack] + SensorValue[rightFront]) <= turnTicks)){}
		motor[leftDT] = 0;
		motor[rightDT] = 0;
	}
	if (direction == right){
		motor[leftDT] = 50;
		motor[rightDT] = -50;
		while (((SensorValue[leftBack] + SensorValue[leftFront]) <= turnTicks) && ((SensorValue[rightBack] + SensorValue[rightFront]) >= -turnTicks)){}
		motor[leftDT] = 0;
		motor[rightDT] = 0;
	}
}

void closeClawTogether()
{
	motor[clawRight] = -100;
	motor[clawLeft] = -100;
	while (SensorValue[leftClawPot] < 3450 || SensorValue[rightClawPot] > 600)
	{
		if (SensorValue[leftClawPot] >= 3450){
			motor[clawLeft] = 0;
		}

		if (SensorValue[rightClawPot] <= 600){
			motor[clawRight] = 0;
		}
		if (vexRT[Btn8U] == 1){
			break;
		}

	}
}

void closeClawCube()
{
	motor[clawRight] = -100;
	motor[clawLeft] = -100;
	while (SensorValue[leftClawPot] < 3200 || SensorValue[rightClawPot] > 760)
	{
		if (SensorValue[leftClawPot] >= 3200){
			motor[clawLeft] = 0;
		}

		if (SensorValue[rightClawPot] <= 760){
			motor[clawRight] = 0;
		}
	}
}

void openClawTogether()
{
	motor[clawRight] = 127;
	motor[clawLeft] = 127;
	resetTimer(T1);
	while (SensorValue[leftClawPot] > 2440 || SensorValue[rightClawPot] < 1321)
	{
		if (SensorValue[leftClawPot] <= 2440){
			motor[clawLeft] = 0;
		}
		if (SensorValue[rightClawPot] >= 1321){
			motor[clawRight] = 0;
		}
		if (getTimer(T1, seconds) > 1){
			break;
		}
		if (vexRT[Btn8U] == 1){
			break;
		}
	}
	motor[clawRight] = 0;
	motor[clawLeft] = 0;
}


// Moves the lift. Takes two parameters: direction and speed.
void moveLift(int direction, int liftSpeed){
	lift = direction * liftSpeed;
	motor[topLeft] = lift;
	motor[midLeft] = lift;
	motor[botLeft] = lift;
	motor[topRight] = lift;
	motor[midRight] = lift;
	motor[botRight] = lift;
}

// Raises the lift
void raiseLift() {
	moveLift(up, liftMaxSpeed);
	if (SensorValue[leftIME] == 700)
	{
		openClawTogether();
	}
}

// Lower the lift
void lowerLift(){
	moveLift(down, liftMaxSpeed);
}

// Controls for the claw
void openClaw(){
	motor[clawRight] = 127;
	motor[clawLeft] = 127;
}

void closeClaw(){
	motor[clawRight] = -127;
	motor[clawLeft] = -127;
}

void stopClaw(){
	motor[clawRight] = 0;
	motor[clawLeft] = 0;
}

// Calls the holdLift() function to lock the lift
void stopLift(){
	moveLift(up, 0);
	autoLowerLift = false;
	autoRaiseLift = false;
}

void percentLift(int percent){
	float target = (percent / 100.0) * liftEncoderMaxValue;
	if (SensorValue[sensorLift] > target){
		lowerLift();
		while (SensorValue[sensorLift] > target){}
		stopLift();
	}
	else if (SensorValue[sensorLift] < target){
		raiseLift();
		while (SensorValue[sensorLift] < target){}
		stopLift();
	}
}

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	int distance1 = 12;
	driveBackwardInches(distance1);
	wait1Msec(333);
	openClawTogether();
	int distance2 = 24;
	wait1Msec(1500);

	for (int i = 1; i <=3; i++){
		if (i != 3)	{
			closeClawCube();
		}

		if (i == 3) {
			closeClaw();
			wait1Msec(500);
			stopClaw();
		}

		driveBackwardInches(distance2 + 7);
		//percentLift(100);
		raiseLift();
		while (SensorValue[sensorLift] < 40){}
		stopLift();
		wait1Msec(333);
		if (i!=3){
			//percentLift(0);
			lowerLift();
			while (SensorValue[sensorLift] > 5){}
			stopLift();
			SensorValue[leftIME] = 0;
			openClawTogether();
			driveForwardInches(distance2 + 8);
		}
	}

	degreeTurn(90, left);
	driveBackwardInches(6);
	percentLift(0);
	driveForwardInches(84);
	closeClaw();
	wait1Msec(500);
	stopClaw();
	driveBackwardInches(6);
	wait1Msec(333);
	degreeTurn(90, right);
	percentLift(100);
	wait1Msec(333);
	percentLift(0);
	driveForwardInches(36);
	closeClawCube();
	driveBackwardInches(36);
	percentLift(100);
	wait1Msec(333);
	percentLift(0);
	degreeTurn(45, left);
	wait1Msec(333);
	driveForwardInches(36);//find out
	wait1Msec(333);
	degreeTurn(45, right);
	wait1Msec(333);
	driveBackwardInches(17);
	wait1Msec(333);
	percentLift(100);
	wait1Msec(333);
	percentLift(0);
	openClawTogether();
	driveForwardInches(36);
	closeClaw();
	wait1Msec(750);
	stopClaw();
	driveBackwardInches(36);
	percentLift(100);
	wait1Msec(333);
	percentLift(5);

}

task usercontrol()
{
	while (true){
		UserControlCodePlaceholderForTesting();
	}
}
