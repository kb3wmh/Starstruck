#pragma config(Sensor, in1,    autoPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  sensor_lift,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightFront,     sensorQuadEncoder)
#pragma config(Sensor, dgtl11, leftFront,      sensorQuadEncoder)
#pragma config(Motor,  port1,           clawRight,     tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftDT,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightDT,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           topRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           midRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           botRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           botLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           midLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           topLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          clawLeft,      tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define e 2.718281828

//Y DRIVETRAIN PROGRAM

//---Motor Connections---//
// Drivetrain -- 2,3,4,5
// Lift -- 7,7,8,9

//-------------Initialize Variables-------------//


// Autonomous Mode Variables
int autonomousMode;
int driveForward = 1;
int driveBack = -1;
int left = 1;
int right = 2;
float wheelBase = 11.0; // Given in inches
float fullTurnCircumference = PI * wheelBase;
float wheelRotationDistance = 4.0 * PI;



//---Variables for User Control---//
bool reverser = false;
bool b7DOld = false;
bool sound = false;
bool b8DOld = false;
bool hold = false;

//---Joystick Variables & Deadzone--//
int Y2 = 0, Y1 = 0, threshold = 15;

//---Constant lift parameters---//
int liftEncoderMaxValue = 127;
int liftEncoderMinValue = 0;
int liftMaxSpeed = 75;
int up = 1;
int down = -1;

//---Used as to control automatic lift---//
bool autoRaiseLift = false;
bool autoLowerLift = false;
bool liftAutoMode = false;
bool autoMiddleLift = false;
int lift;

//-------------Robot Functions-------------//

// Stops the drivetrain movement
void stopMovement(){
	motor[leftDT] = 0;
	motor[rightDT] = 0;
}

// USAGE: drive([driveForward, driveBack], distanceInInches);
void drive(int direction, int distance) {
	// Calculate number of ticks to travel
	float numberOfRotations = distance / (4.0 * PI);
	float numberOfTicks = numberOfRotations / 360.0;

	// Determine the robot's current position
	int leftDTPos = SensorValue[leftFront];
	int rightDTPos = SensorValue[rightFront];

	// Adds/Subtracts the target number of ticks to travel
	int targetLeftDTPos = leftDTPos + (direction * numberOfTicks);
	int targetRightDTPos = rightDTPos + (direction * numberOfTicks);

	// Forward
	if (direction == 1){
		while ((SensorValue[leftFront] < targetLeftDTPos) || (SensorValue[rightFront] < targetRightDTPos)){
			if (SensorValue[leftFront] < targetLeftDTPos){
				motor[leftDT] = 80;
			}
			else{
				motor[leftDT] = 0;
			}

			if (SensorValue[rightFront] < targetLeftDTPos){
				motor[rightDT] = 80;
			}
			else{
				motor[rightDT] = 0;
			}
		}
		stopMovement();
	}

	// Reverse
	else {
		while ((SensorValue[leftFront] > targetLeftDTPos) || (SensorValue[rightFront] > targetRightDTPos)){
			if (SensorValue[leftFront] > targetLeftDTPos){
				motor[leftDT] = -80;
			}
			else{
				motor[leftDT] = 0;
			}

			if (SensorValue[rightFront] > targetLeftDTPos){
				motor[rightDT] = -80;
			}
			else{
				motor[rightDT] = 0;
			}
		}
		stopMovement();
	}

}

// Moves the lift. Takes two parameters: direction and speed.
void moveLift(int direction, int liftSpeed){
	lift = direction * liftSpeed;
	motor[topLeft] = lift;
	motor[midLeft] = lift;
	motor[botLeft] = lift;
	motor[topRight] = lift;
	motor[midRight] = lift;
	motor[botRight] = lift;
}

// Backspins the lift motors to keep it from falling
void holdLift() {
	moveLift(up, 10);
}

// Calls the holdLift() function to lock the lift
void stopLift(){
	holdLift();
	autoLowerLift = false;
	autoRaiseLift = false;
}

// Raises the lift
void raiseLift() {
	moveLift(up, liftMaxSpeed);
}

// Lower the lift
void lowerLift(){
	moveLift(down, liftMaxSpeed);
}

// Controls for the claw
void openClaw(){
	motor[clawRight] = 127;
	motor[clawLeft] = 127;
}

void closeClaw(){
	motor[clawRight] = -127;
	motor[clawLeft] = -127;
}

void stopClaw(){
	motor[clawRight] = 0;
	motor[clawLeft] = 0;
}

// Automatic lift function: takes three parameters, telling it what mode to enter.
void automaticLift(bool autoRaiseLift, bool autoLowerLift, bool autoMiddleLift) {
	// These statements stop the lift once it has reached its desired height
	if (autoRaiseLift || autoLowerLift || autoMiddleLift){
		if (SensorValue[sensor_lift] > liftEncoderMaxValue){
			autoRaiseLift = false;
		}
		if (SensorValue[sensor_lift] < liftEncoderMinValue){
			autoLowerLift = false;
		}
		if (autoMiddleLift && (SensorValue[sensor_lift] <= 55) && (SensorValue[sensor_lift] >= 50)){
			autoMiddleLift = false;
		}
		if (autoRaiseLift == false && autoLowerLift == false && autoMiddleLift == false){
			stopLift();
			liftAutoMode = false;
		}
	}

	// Moves the lift
	if (autoRaiseLift) {
		raiseLift();
	}
	if (autoLowerLift) {
		lowerLift();
	}
	// For positioning the lift in the center, determines whether it needs to go up or down
	if (autoMiddleLift){
		if (SensorValue[sensor_lift] > 55){
			lowerLift();
		}
		if (SensorValue[sensor_lift] < 50) {
			raiseLift();
		}
	}
}

// turnAngle -- Degrees
int calculateEncoderTurn(float turnAngle){
	float turnAngleInRadians = turnAngle * (PI / 180);
	float distanceToTravel = turnAngleInRadians / fullTurnCircumference;
	float wheelRotations = distanceToTravel / wheelRotationDistance;
	int encoderTicks = wheelRotations * 90.0;

	return encoderTicks;
}

// USAGE -- turn(degrees, [left, right]);
void turn(float turnAngle, int direction){
	int encoderTicks = calculateEncoderTurn(turnAngle);
	if (direction == right){
		int leftTarget = encoderTicks;
		int rightTarget = -1 * encoderTicks;
		int currentLeftPos = SensorValue[leftFront];
		int currentRightPos = SensorValue[rightFront];

		leftTarget += currentLeftPos;
		rightTarget += currentRightPos;

		while ((SensorValue[rightFront] > rightTarget) && (SensorValue[leftFront] < leftTarget)){
			motor[leftDT] = 63;
			motor[rightDT] = -63;
		}
	}

	if (direction == left){
		int leftTarget = -1 * encoderTicks;
		int rightTarget = encoderTicks;
		int currentLeftPos = SensorValue[leftFront];
		int currentRightPos = SensorValue[rightFront];

		leftTarget += currentLeftPos;
		rightTarget += currentRightPos;

		while (( SensorValue[rightFront] < rightTarget) && (SensorValue[leftFront] > rightTarget)){
			motor[leftDT] = -63;
			motor[rightDT] = 63;
		}
	}
	stopMovement();
}



void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	/*// Sets up the LCD display with the auto selection menu
	clearLCDLine(0);
	clearLCDLine(1);

	displayLCDString(0,0,"|");
	displayLCDString(1, 0, "V");
	displayLCDString(0,16,"|");
	displayLCDString(1,16, "V");
	displayLCDCenteredString(0, "1-Auto Mode-2");
	autonomousMode = 1; // Default auto is 1
	while(true){
	if (nLCDButtons == 1){
	autonomousMode = 1;
	setLCDPosition(1,8);
	displayNextLCDNumber(1);
	}
	if (nLCDButtons == 4){
	autonomousMode = 2;
	setLCDPosition(1,8);
	displayNextLCDNumber(2);
	}
	}*/
}

//-------------Autonomous Code-------------//


task autonomous()
{
	autonomousMode = -1;
	playSoundFile("sound.wav"); // BOW DOWN BEFORE US!!
	motor[rightDT] = 100;
	motor[leftDT] = 100;

	wait1Msec(3000);
	motor[rightDT] = 0;
	motor[leftDT] = 0;
	// Turns left, gets the stars in the back, and dumps them over the fence (hopefully...)
	/*if (autonomousMode == 1){
		turn(90, right);
		openClaw();
		wait1Msec(500);
		stopClaw();
		drive(driveForward, 72);
		closeClaw();
		wait1Msec(500);
		stopClaw();

		turn(90, left);
		drive(driveForward, 36);
		turn(left, 180);
		automaticLift(true,false, false);
		drive(driveBack, 30);
		openClaw();
		wait1Msec(500);
		closeClaw();
	}

	// Grabs the cube from the middle of the court
	else if (autonomousMode == 2) {
		openClaw();
		wait1Msec(500);
		stopClaw();
		drive(driveForward, 50);
		closeClaw();
		wait1Msec(250);
		stopClaw();
		turn(left, 124);
		automaticLift(true, false, false);
		drive(driveBack, 40);
		openClaw();
		wait1Msec(500);
		stopClaw();
	}*/
}

//-------------User Control Code-------------//

task usercontrol()
{
	while (true)
	{
		// Strike fear into the hearts of our opponents
		if (!sound && vexRT[Btn8U]==1){
			playSoundFile("sound.wav");
			sound = true;
		}
		if (sound && vexRT[Btn8D]==0){
			sound = false;
		}

		// Enables reverse mode
		if (vexRT[Btn7D] == 1 && !b8DOld) {
			if (reverser == false){
				reverser = true;
			}
			else if (reverser){
				reverser = false;
			}
			b7DOld = true;
		}

		if (vexRT[Btn7D] == 0 && b7DOld){
			b7DOld = false;
		}

		//Create "deadzone" for Y1/Ch2
		if(abs(vexRT[Ch2]) > threshold){
			Y1 = vexRT[Ch2];
			Y1 = -(46.72068903 * exp(Y1/96.70578317) - 46.72068903);
		}
		else
			Y1 = 0;
		//Create "deadzone" for Y2/Ch3
		if(abs(vexRT[Ch3]) > threshold){
			Y2 = vexRT[Ch3];
			Y2 = 46.72068903 * exp(Y2/96.70578317) - 46.72068903;
		}
		else
			Y2 = 0;


		//Remote Control Commands

		if (reverser){ // Reverses the controls
			motor[rightDT] = Y2;
			motor[leftDT] = -Y1;
		}
		if (!reverser){
			motor[rightDT] = Y1;
			motor[leftDT] = -Y2;
		}

		//---Manual Lift Control--//

		// Disable the automatic lift if any manual lift input detected
		if (vexRT[Btn6D] == 1 || vexRT[Btn6U] == 1 || vexRT[Btn8D] == 1){
			liftAutoMode = false;
		}

		// Raise lift
		if (vexRT[Btn6U] == 1 && !hold) {
			raiseLift();
		}

		// Lower lift
		if (vexRT[Btn6D] == 1 && !hold) {
			lowerLift();
		}

		// Enable or disable hold mode
		if (vexRT[Btn8D] == 1 && !b8DOld){
			if (hold == false){
				hold = true;
			}
			else{
				hold = false;
			}
			b8DOld = true;
		}
		if (vexRT[Btn8D] == 0 && b8DOld){
			b8DOld = false;
		}

		// Locks the lift in place
		if (hold){
			holdLift();
		}

		// Manually disable the lift
		if (vexRT[Btn6U] == 0 && !hold && vexRT[Btn6D] == 0 && !liftAutoMode) {
			stopLift();
		}

		// Claw
		if (vexRT[Btn5U] == 1){
			openClaw();
		}
		if (vexRT[Btn5D] == 1){
			closeClaw();
		}
		if (vexRT[Btn5D] == 0 && vexRT[Btn5U] == 0){
			stopClaw();
		}

		//--- Automatic Lift Control---//

		// Enables automatic raise to top
		if (vexRT[Btn7R] == 1 && !autoRaiseLift){
			autoLowerLift = false;
			autoRaiseLift = true;
			autoMiddleLift = false;
			liftAutoMode = true;
		}

		// Enables automatic lower to bottom
		if (vexRT[Btn7L] == true && !autoLowerLift) {
			autoRaiseLift = false;
			autoLowerLift = true;
			autoMiddleLift = false;
			liftAutoMode = true;
		}

		// Enables raise or lower to midpoint
		if (vexRT[Btn7U] == true && !autoLowerLift) {
			autoRaiseLift = false;
			autoLowerLift = false;
			autoMiddleLift = true;
			liftAutoMode = true;
		}

		// Execute the automatic raise
		if (liftAutoMode){
			automaticLift(autoRaiseLift, autoLowerLift, autoMiddleLift);
		}
		// Turns off the automatic lift
		if ((autoLowerLift || autoRaiseLift || autoMiddleLift) && !liftAutoMode){
			stopLift();
		}
	}
}
